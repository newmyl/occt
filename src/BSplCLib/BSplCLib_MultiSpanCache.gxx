// Copyright (c) 2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <BSplCLib.hxx>
#include <ElCLib.hxx>

template<class POINT_TYPE, class VEC_TYPE>
BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::BSplCLib_MultiSpanCacheBase(
  const Standard_Integer         theDegree,
  const Standard_Boolean         thePeriodic,
  const Array1OfPOINT&           thePoles,
  const TColStd_Array1OfReal*    theWeights)
  : myDegree(theDegree),
    myPeriodic(thePeriodic),
    myFirstKnot(0.),
    myLastKnot(1.),
    myKnots(NULL),
    myMults(NULL),
    myFlatKnots(NULL),
    myPoles(thePoles),
    myWeights(theWeights),
    mySingleSpan(Standard_True),
    myCaches(1),
    myLastCacheInd(0)
{
  // Build cache for single span
  TColStd_Array1OfReal aFlatKnots(BSplCLib::FlatBezierKnots(myDegree), 1, (myDegree + 1) * 2);
  myCaches[myLastCacheInd] = new BSplCLib_Cache;
  myCaches[myLastCacheInd]->BuildCache(myDegree, myPeriodic, aFlatKnots, myDegree + 1, myPoles, myWeights);
}

template<class POINT_TYPE, class VEC_TYPE>
BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::BSplCLib_MultiSpanCacheBase(
  const Standard_Integer         theDegree,
  const Standard_Boolean         thePeriodic,
  const TColStd_Array1OfReal*    theKnots,
  const TColStd_Array1OfInteger* theMults,
  const TColStd_Array1OfReal*    theFlatKnots,
  const Array1OfPOINT&           thePoles,
  const TColStd_Array1OfReal*    theWeights)
  : myDegree(theDegree),
    myPeriodic(thePeriodic),
    myFirstKnot(theKnots->First()),
    myLastKnot(theKnots->Last()),
    myKnots(theKnots),
    myMults(theMults),
    myFlatKnots(theFlatKnots),
    myPoles(thePoles),
    myWeights(theWeights),
    mySingleSpan(theKnots->Length() == 2),
    myCaches(theKnots->Upper() - theKnots->Lower()),
    myLastCacheInd(0)
{
}

template<class POINT_TYPE, class VEC_TYPE>
BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::~BSplCLib_MultiSpanCacheBase()
{
  Standard_Integer aSize = (Standard_Integer)myCaches.Size();
  for (Standard_Integer i = 0; i < aSize; ++i)
    myCaches[i].Nullify();
}

template<class POINT_TYPE, class VEC_TYPE>
void BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::D0(const Standard_Real theParameter,
                                                                 POINT_TYPE&   thePoint)
{
  Standard_Real aPar = theParameter;
  const Handle(BSplCLib_Cache)& aCache = FindCache(aPar);
  aCache->D0(aPar, thePoint);
}

template<class POINT_TYPE, class VEC_TYPE>
void BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::D1(const Standard_Real theParameter,
                                                                 POINT_TYPE&   thePoint,
                                                                 VEC_TYPE&     theTangent)
{
  Standard_Real aPar = theParameter;
  const Handle(BSplCLib_Cache)& aCache = FindCache(aPar);
  aCache->D1(aPar, thePoint, theTangent);
}

template<class POINT_TYPE, class VEC_TYPE>
void BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::D2(const Standard_Real theParameter,
                                                                 POINT_TYPE&   thePoint,
                                                                 VEC_TYPE&     theTangent,
                                                                 VEC_TYPE&     theCurvature)
{
  Standard_Real aPar = theParameter;
  const Handle(BSplCLib_Cache)& aCache = FindCache(aPar);
  aCache->D2(aPar, thePoint, theTangent, theCurvature);
}

template<class POINT_TYPE, class VEC_TYPE>
void BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::D3(const Standard_Real theParameter,
                                                                 POINT_TYPE&   thePoint,
                                                                 VEC_TYPE&     theTangent,
                                                                 VEC_TYPE&     theCurvature,
                                                                 VEC_TYPE&     theTorsion)
{
  Standard_Real aPar = theParameter;
  const Handle(BSplCLib_Cache)& aCache = FindCache(aPar);
  aCache->D3(aPar, thePoint, theTangent, theCurvature, theTorsion);
}

template<class POINT_TYPE, class VEC_TYPE>
Standard_Integer BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::SpanIndex(const Standard_Real theParameter) const
{
  if (mySingleSpan)
    return 1;

  // Get index of a span
  Standard_Integer aSpanIndex = 0;
  Standard_Real aNewPar = theParameter; // unused parameter, because theParameter is already in period 
  BSplCLib::LocateParameter(myDegree, *myKnots, myMults, theParameter, myPeriodic,
                            aSpanIndex, aNewPar);
  return aSpanIndex;
}

template<class POINT_TYPE, class VEC_TYPE>
const Handle(BSplCLib_Cache)&
BSplCLib_MultiSpanCacheBase<POINT_TYPE, VEC_TYPE>::FindCache(Standard_Real& theParameter)
{
  // Normalize the parameters for periodical B-splines
  if (myPeriodic && (theParameter > myLastKnot || theParameter < myFirstKnot))
    theParameter = ElCLib::InPeriod(theParameter, myFirstKnot, myLastKnot);

  // Do not want to use LocateParameter due to lack of performance.
  // Just check the last used cache is valid for the given parameter.
  if (!myCaches[myLastCacheInd].IsNull() &&
      (mySingleSpan || myCaches[myLastCacheInd]->IsCacheValid(theParameter)))
      return myCaches[myLastCacheInd];

  Standard_Integer aSpanIndex = SpanIndex(theParameter);
  myLastCacheInd = aSpanIndex - (myKnots ? myKnots->Lower() : 1);
  // check the cache is already built
  Handle(BSplCLib_Cache)& aCache = myCaches[myLastCacheInd];
  if (aCache.IsNull())
  {
    // calculate index of cache for the flat knots
    aSpanIndex = BSplCLib::FlatIndex(myDegree, aSpanIndex, *myMults, myPeriodic);
    // build new cache
    aCache = new BSplCLib_Cache;
    aCache->BuildCache(myDegree, myPeriodic, *myFlatKnots, aSpanIndex, myPoles, myWeights);
  }

  return aCache;
}
