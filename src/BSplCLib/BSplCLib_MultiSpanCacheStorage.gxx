// Copyright (c) 2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <Standard_NegativeValue.hxx>

template<class CACHE_TYPE>
BSplCLib_MultiSpanCacheStorage<CACHE_TYPE>::BSplCLib_MultiSpanCacheStorage(const Standard_Integer theMaxSpans)
  : myMaxSpansCount(theMaxSpans),
    mySingleSpan(Standard_False),
    myCaches(theMaxSpans),
    myCachedSpans(theMaxSpans),
    myNbSpans(0)
{
  myLastCache.mySpan = -1;
}

template<class CACHE_TYPE>
void BSplCLib_MultiSpanCacheStorage<CACHE_TYPE>::SetMaxSpansCached(const Standard_Integer theMaxSpans)
{
  // number of cached spans should not be lesser than 1
  Standard_NegativeValue_Raise_if(theMaxSpans < 1, "Number of cached spans should be greater than 0");

  if (theMaxSpans == myMaxSpansCount)
    return;

  Clear();
  myMaxSpansCount = theMaxSpans;
  myCaches.Allocate(myMaxSpansCount);
  myCachedSpans.Allocate(myMaxSpansCount);
}

template<class CACHE_TYPE>
void BSplCLib_MultiSpanCacheStorage<CACHE_TYPE>::Clear()
{
  myNbSpans = 0;
  myLastCache.mySpan = -1;
  myLastCache.myCache.Nullify();
}

template<class CACHE_TYPE> Standard_Boolean
BSplCLib_MultiSpanCacheStorage<CACHE_TYPE>::CreateNewCache(const Standard_Integer theSpanIndex,
                                                           Handle(CACHE_TYPE)&    theCache)
{
  Standard_Boolean isNeedRebuild = Standard_False;
  // Do not want to allocate memory. Update already existent cache if all slots are filled.
  if (myMaxSpansCount == 1)
  {
    isNeedRebuild = myLastCache.myCache.IsNull();
    if (isNeedRebuild)
      theCache = new CACHE_TYPE;
    else { // rebuild cache, if the curve/surface has more than one span
      isNeedRebuild = !mySingleSpan;
      theCache = myLastCache.myCache;
    }
  }
  else
  {
    Standard_Integer aSpanIndex = myNbSpans;
    Standard_Integer aCacheIndex = myNbSpans;
    if (myNbSpans >= myMaxSpansCount)
    { // will rebuild existent cache to avoid memory reallocation
      aSpanIndex -= 1; // to identify first cached span
      aCacheIndex = myCachedSpans[aSpanIndex].myIndex;
      theCache = myCaches[aCacheIndex];
    }
    else
    { // create new cache
      theCache = new CACHE_TYPE;
      myCaches[myNbSpans++] = theCache;
    }
    ShiftCachedSpans(aSpanIndex);
    myCachedSpans[0] = IndexedSpan(theSpanIndex, aCacheIndex);
    isNeedRebuild = Standard_True;
  }

  myLastCache.mySpan = theSpanIndex;
  myLastCache.myCache = theCache;
  return isNeedRebuild;
}

template<class CACHE_TYPE> Standard_Boolean
BSplCLib_MultiSpanCacheStorage<CACHE_TYPE>::SetLatestCache(const Standard_Integer theSpanIndex)
{
  if (myMaxSpansCount <= 1)
    return Standard_False;

  // search given index and push it to back of the list
  Standard_Integer anIndex = 0;
  for (; anIndex < myNbSpans; ++anIndex)
    if (myCachedSpans[anIndex].mySpan == theSpanIndex)
    {
      IndexedSpan anIndices = myCachedSpans[anIndex];
      ShiftCachedSpans(anIndex);
      myCachedSpans[0] = anIndices;
      break;
    }
  if (anIndex == myNbSpans)
    return Standard_False;

  myLastCache.mySpan = theSpanIndex;
  myLastCache.myCache = myCaches[myCachedSpans[0].myIndex];
  return Standard_True;
}

template<class CACHE_TYPE>
void BSplCLib_MultiSpanCacheStorage<CACHE_TYPE>::ShiftCachedSpans(Standard_Integer theNbElems)
{
  memmove(myCachedSpans + 1, myCachedSpans, theNbElems * sizeof(IndexedSpan));
}
