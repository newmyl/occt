Fundamental Concepts {#user_guides__visu_fundaments}
=============
@tableofcontents 

@section occt_visu_2_1 Presentation 

In Open CASCADE Technology, presentation services are  separated from the data, which they represent, which is generated by  applicative algorithms.  This division allows you to modify a geometric or topological   algorithm and its resulting objects without modifying the visualization  services.  

@subsection occt_visu_2_1_1 Presentation Structure

Displaying an object on the screen involves three kinds of entities:
  * a presentable object, the *AIS_InteractiveObject*
  * a viewer 
  * an interactive context, the *AIS_InteractiveContext*. 

<h4>The presentable object</h4>
The purpose of a presentable object is to provide the  graphical representation of an object in the form of *Graphic3d* structure. On  the first display request, it creates this structure by calling the appropriate  algorithm and retaining this framework for further display.  

Standard presentation algorithms are provided in the *StdPrs*  and *Prs3d* packages. You can, however, write specific presentation algorithms of  your own, provided that they create presentations made of structures from the *Graphic3d* packages. You can also create several presentations of a single  presentable object: one for each visualization mode supported by your  application.  

Each object to be presented individually must be presentable  or associated with a presentable object. 

###The viewer
The viewer allows interactively manipulating views of the object. When you zoom, translate or rotate a view, the viewer operates on  the graphic structure created by the presentable object and not on the data  model of the application. Creating Graphic3d structures in your presentation  algorithms allows you to use the 3D viewers provided in Open CASCADE Technology for 3D visualisation.  

###The Interactive Context
The  interactive context controls the entire presentation process from a common  high-level API. When the application requests the display of an object, the  interactive context requests the graphic structure from the presentable object  and sends it to the viewer for displaying. 

@subsection occt_visu_2_1_2 Presentation Packages

Presentation involves at least the *AIS, PrsMgr, StdPrs* and  *V3d* packages. Additional packages, such as *Prs3d* and *Graphic3d* may be used if  you need to implement your own presentation algorithms.  

* *AIS* package provides all  classes to implement interactive objects (presentable and selectable entities).  
* *PrsMgr* package   provides low level services and is only to be used when you do not want to use the services provided by AIS. It contains all classes needed to implement the presentation process: abstract classes *Presentation*  and *PresentableObject*  and concrete class *PresentationManager3d*.
* *StdPrs* package  provides ready-to-use standard presentation algorithms for specific geometries: points, curves and  shapes of the geometry and topology toolkits.
* *Prs3d* package provides generic presentation algorithms such as wireframe, shading and hidden line removal associated with a *Drawer* class, which controls the attributes of the presentation to be created in terms of color, line type, thickness, etc.
* *V3d* package provides  the services supported by the 3D viewer.
* *Graphic3d* package provides resources to create 3D graphic structures.
* *Visual3d* package contains classes implementing commands for 3D viewer.
* *DsgPrs* package provides tools for display of dimensions, relations and XYZ trihedrons.

@subsection occt_visu_2_1_3 A Basic Example: How to display a 3D object 

~~~~~
Void Standard_Real dx  = ...; //Parameters   
Void Standard_Real dy  = ...; //to build  a wedge  
Void Standard_Real dz  = ...;  
Void Standard_Real ltx = ...; 

Handle(V3d_Viewer)aViewer = ...;  
Handle(AIS_InteractiveContext)aContext;  
aContext = new AIS_InteractiveContext(aViewer);     

BRepPrimAPI_MakeWedge w(dx, dy, dz, ltx);  
TopoDS_Solid & = w.Solid();  
Handle(AIS_Shape) anAis = new AIS_Shape(S);  
//creation of the presentable  object  
aContext -> Display(anAis);  
//Display the presentable  object in the 3d viewer. 
~~~~~

The shape is created using the *BRepPrimAPI_MakeWedge*  command. An *AIS_Shape* is then created from the shape. When calling the *Display* command, the interactive context calls the Compute method of the  presentable object to calculate the presentation data and transfer it to the  viewer. See figure below.  

@image html visualization_image004.svg "Processes involved in displaying a presentable shape"
@image latex visualization_image004.svg "Processes involved in displaying a presentable shape"

@section occt_visu_2_2 Selection 

Standard OCCT selection algorithm is represented by 2 parts: dynamic and static. Dynamic selection causes objects to be automatically highlighted as the mouse cursor moves over them. Static selection allows to pick particular object (or objects) for further processing.

There are 3 different selection types:
  - **Point selection** -- allows picking and highlighting a single object (or its part) located under the mouse cursor;
  - **Rectangle selection** -- allows picking objects or parts located under the rectangle defined by the start and end mouse cursor positions;
  - **Polyline selection** -- allows picking objects or parts located under a user-defined non-self-intersecting polyline.

For OCCT selection algorithm, all selectable objects are represented as a set of sensitive zones, called <b>sensitive entities</b>. When the mouse cursor moves in the view, the sensitive entities of each object are analyzed for collision.

@subsection occt_visu_2_2_1 Terms and Notions

This section introduces basic terms and notions used throughout the algorithm description.

###Sensitive entity

Sensitive entities in the same way as entity owners are links between objects and the selection mechanism.

The purpose of entities is to define what parts of the object will be selectable in particular. Thus, any object that is meant to be selectable must be split into sensitive entities (one or several). For instance, to apply face selection to an object it is necessary to explode it into faces and use them for creation of a sensitive entity set.

@image html visualization_image005.png "Example of a shape divided into sensitive entities"
@image latex visualization_image005.png "Example of a shape divided into sensitive entities"

Depending on the user's needs, sensitive entities may be atomic (point or edge) or complex. Complex entities contain many sub-elements that can be handled by detection mechanism in a similar way (for example, a polyline stored as a set of line segments or a triangulation).

Entities are used as internal units of the selection algorithm and do not contain any topological data, hence they have a link to an upper-level interface that maintains topology-specific methods.

###Entity owner

Each sensitive entity stores a reference to its owner, which is a class connecting the entity and the corresponding selectable object. Besides, owners can store any additional information, for example, the topological shape of the sensitive entity, highlight colors and methods, or if the entity is selected or not.  

###Selection

To simplify the handling of different selection modes of an object, sensitive entities linked to its owners are organized into sets, called **selections**.

Each selection contains entities created for a certain mode along with the sensitivity and update states.

###Selectable object

Selectable object stores information about all created selection modes and sensitive entities.

All successors of a selectable object must implement the method that splits its presentation into sensitive entities according to the given mode. The computed entities are arranged in one selection and added to the list of all selections of this object. No selection will be removed from the list until the object is deleted permanently.

For all standard OCCT shapes, zero mode is supposed to select the whole object (but it may be redefined easily in the custom object). For example, the standard OCCT selection mechanism and *AIS_Shape* determine the following modes:
  - 0 -- selection of the *AIS_Shape*;
  - 1 -- selection of the vertices;
  - 2 -- selection of the edges;
  - 3 -- selection of the wires;
  - 4 -- selection of the faces;
  - 5 -- selection of the shells;
  - 6 -- selection of the constituent solids.

@image html visualization_image006.png "Hierarchy of references from sensitive entity to selectable object"
@image latex visualization_image006.png "Hierarchy of references from sensitive entity to selectable object"

@image html visualization_image007.png "The principle of entities organization within the selectable object"
@image latex visualization_image007.png "The principle of entities organization within the selectable object"

###Viewer selector

For each OCCT viewer there is a **Viewer selector** class instance. It provides a high-level API for the whole selection algorithm and encapsulates the processing of objects and sensitive entities for each mouse pick.

The viewer selector maintains activation and deactivation of selection modes, launches the algorithm, which detects candidate entities to be picked, and stores its results, as well as implements an interface for keeping selection structures up-to-date.

###Selection manager

Selection manager is a high-level API to manipulate selection of all displayed objects. It handles all viewer selectors, activates and deactivates selection modes for the objects in all or particular selectors, manages computation and update of selections for each object. Moreover, it keeps selection structures updated taking into account applied changes.

@image html visualization_image008.png "The relations chain between viewer selector and selection manager"
@image latex visualization_image008.png "The relations chain between viewer selector and selection manager"

@subsection occt_visu_2_2_2 Algorithm

All three types of OCCT selection are implemented as a single concept, based on the search for overlap between frustum and sensitive entity through 3-level BVH tree traversal.

###Selection Frustum

The first step of each run of selection algorithm is to build the selection frustum according to the currently activated selection type.

For the point or the rectangular selection the base of the frustum is a rectangle built in conformity with the pixel tolerance or the dimensions of a user-defined area, respectively. For the polyline selection, the polygon defined by the constructed line is triangulated and each triangle is used as the base for its own frustum. Thus, this type of selection uses a set of triangular frustums for overlap detection.

The frustum length is limited by near and far view volume planes and each plane is built parallel to the corresponding view volume plane.

@image html visualization_image009.png "Rectangular frustum: a) after mouse move or click, b) after applying the rectangular selection"
@image latex visualization_image009.png "Rectangular frustum: a) after mouse move or click, b) after applying the rectangular selection"

@image html visualization_image010.png "Triangular frustum set: a) user-defined polyline, b) triangulation of the polygon based on the given polyline, c) triangular frustum based on one of the triangles"
@image latex visualization_image010.png "Triangular frustum set: a) user-defined polyline, b) triangulation of the polygon based on the given polyline, c) triangular frustum based on one of the triangles"

###BVH trees

To maintain selection mechanism at the viewer level, a speedup structure composed of 3 BVH trees is used.

The first level tree is constructed of axis-aligned bounding boxes of each selectable object. Hence, the root of this tree contains the combination of all selectable boundaries even if they have no currently activated selections. Objects are added during the display of <i>AIS_InteractiveObject</i> and will be removed from this tree only when the object is destroyed. The 1st level BVH tree is build on demand simultaneously with the first run of the selection algorithm.

The second level BVH tree consists of all sensitive entities of one selectable object. The 2nd level trees are built automatically when the default mode is activated and rebuilt whenever a new selection mode is calculated for the first time.

The third level BVH tree is used for complex sensitive entities that contain many elements: for example, triangulations, wires with many segments, point sets, etc. It is built on demand for sensitive entities with under 800K sub-elements.

@image html visualization_image022.png "Selection BVH tree hierarchy: from the biggest object-level (first) to the smallest complex entity level (third)"
@image latex visualization_image022.png "Selection BVH tree hierarchy: from the biggest object-level (first) to the smallest complex entity level (third)"

###Stages of the algorithm

The algorithm includes pre-processing and three main stages.

* **Pre-processing** -- implies calculation of the selection frustum and its main characteristics.
* **First stage** -- traverse of the first level BVH tree.

After successful building of the selection frustum, the algorithm starts traversal of the object-level BVH tree. The nodes containing axis-aligned bounding boxes are tested for overlap with the selection frustum following the terms of <i>separating axis theorem (SAT)</i>. When the traverse goes down to the leaf node, it means that a candidate object with possibly overlapping sensitive entities has been found. If no such objects have been detected, the algorithm stops and it is assumed that no object needs to be selected. Otherwise it passes to the next stage to process the entities of the found selectable.

* **Second stage** -- traverse of the second level BVH tree

At this stage it is necessary to determine if there are candidates among all sensitive entities of one object.

First of all, at this stage the algorithm checks if there is any transformation applied for the current object. If it has its own location, then the correspondingly transformed frustum will be used for further calculations. At the next step the nodes of the second level BVH tree of the given object are visited to search for overlapping leaves. If no such leafs have been found, the algorithm returns to the second stage. Otherwise it starts processing the found entities by performing the following checks:
  - activation check - the entity may be inactive at the moment as it belongs to deactivated selection;
  - tolerance check - current selection frustum may be too large for further checks as it is always built with the maximum tolerance among all activated entities. Thus, at this step the frustum may be scaled.

After these checks the algorithm passes to the last stage.

* **Third stage** -- overlap or inclusion test of a particular sensitive entity

If the entity is atomic, a simple SAT test is performed. In case of a complex entity, the third level BVH tree is traversed. The quantitative characteristics (like depth, distance to the center of geometry) of matched sensitive entities is analyzed and clipping planes are applied (if they have been set). The result of detection is stored and the algorithm returns to the second stage.

@subsection occt_visu_2_2_3 Packages and Classes

Selection is implemented as a combination of various algorithms divided among several packages -- <i>SelectBasics</i>, <i>Select3D</i>, <i>SelectMgr</i> and <i>StdSelect</i>.

###SelectBasics

<i>SelectBasics</i> package contains basic classes and interfaces for selection. The most notable are:
  - <i>SelectBasics_SensitiveEntity</i> -- the base definition of a sensitive entity;
  - <i>SelectBasics_EntityOwner</i> -- the base definition of the an entity owner -- the link between the sensitive entity and the object to be selected;
  - <i>SelectBasics_PickResult</i> -- the structure for storing quantitative results of detection procedure, for example, depth and distance to the center of geometry;
  - <i>SelectBasics_SelectingVolumeManager</i> -- the interface for interaction with the current selection frustum.

Each custom sensitive entity must inherit at least <i>SelectBasics_SensitiveEntity</i>.

###Select3D

<i>Select3D</i> package provides a definition of standard sensitive entities, such as:
  - box;
  - circle;
  - curve;
  - face;
  - group;
  - point;
  - segment;
  - triangle;
  - triangulation;
  - wire.

Each basic sensitive entity inherits <i>Select3D_SensitiveEntity</i>, which is a child class of <i>SelectBasics_SensitiveEntity</i>.

The package also contains two auxiliary classes, <i>Select3D_SensitivePoly</i> and <i>Select3D_SensitiveSet</i>.

<i>Select3D_SensitivePoly</i> -- describes an arbitrary point set and implements basic functions for selection. It is important to know that this class does not perform any internal data checks. Hence, custom implementations of sensitive entity inherited from <i>Select3D_SensitivePoly</i> must satisfy the terms of Separating Axis Theorem to use standard OCCT overlap detection methods.

<i>Select3D_SensitiveSet</i> -- a base class for all complex sensitive entities that require the third level BVH usage. It implements traverse of the tree and defines an interface for the methods that check sub-entities.

<h4>SelectMgr</h4>

<i>SelectMgr</i> package is used to maintain the whole selection process. For this purpose, the package provides the following services:
  - activation and deactivation of selection modes for all selectable objects;
  - interfaces to compute selection mode of the object;
  - definition of selection filter classes;
  - keeping selection BVH data up-to-date.

A brief description of the main classes:
  - <i>SelectMgr_FrustumBase</i>, <i>SelectMgr_Frustum</i>, <i>SelectMgr_RectangularFrustum</i>, <i>SelectMgr_TriangluarFrustum</i> and <i>SelectMgr_TriangularFrustumSet</i> -- interfaces and implementations of selecting frustums, these classes implement different SAT tests for overlap and inclusion detection. They also contain methods to measure characteristics of detected entities (depth, distance to center of geometry);
  - <i>SelectMgr_SensitiveEntity</i>, <i>SelectMgr_Selection</i> and <i>SelectMgr_SensitiveEntitySet</i> -- store and handle sensitive entities; <i>SelectMgr_SensitiveEntitySet</i> implements a primitive set for the second level BVH tree;
  - <i>SelectMgr_SelectableObject</i> and <i>SelectMgr_SelectableObjectSet</i> -- describe selectable objects. They also manage storage, calculation and removal of selections. <i>SelectMgr_SelectableObjectSet</i> implements a primitive set for the first level BVH tree;
  - <i>SelectMgr_ViewerSelector</i> -- encapsulates all logics of the selection algorithm and implements the third level BVH tree traverse;
  - <i>SelectMgr_SelectionManager</i> -- manages activation/deactivation, calculation and update of selections of every selectable object, and keeps BVH data up-to-date.

<h4>StdSelect</h4>

<i>StdSelect</i> package contains the implementation of some <i>SelectMgr</i> classes and tools for creation of selection structures. For example,
  - <i>StdSelect_BRepOwner</i> -- defines an entity owner with a link to its topological shape and methods for highlighting;
  - <i>StdSelect_BRepSelectionTool</i> -- contains algorithms for splitting standard AIS shapes into sensitive primitives;
  - <i>StdSelect_ViewerSelector3d</i> -- an example of <i>SelectMgr_ViewerSelecor</i> implementation, which is used in a default OCCT selection mechanism;
  - <i>StdSelect_FaceFilter</i>, <i>StdSelect_EdgeFilter</i> -- implementation of selection filters.

@subsection occt_visu_2_2_4 Examples of Usage

The first code snippet illustrates the implementation of <i>SelectMgr_SelectableObject::ComputeSelection()</i> method in a custom interactive object. The method is used for computation of user-defined selection modes.

Let us assume it is required to make a box selectable in two modes -- the whole shape (mode 0) and each of its edges (mode 1).

To select the whole box, the application can create a sensitive primitive for each face of the interactive object. In this case, all primitives share the same owner -- the box itself.

To select box's edge, the application must create one sensitive primitive per edge. Here all sensitive entities cannot share the owner since different geometric primitives must be highlighted as the result of selection procedure.

~~~~

void InteractiveBox::ComputeSelection (const  Handle(SelectMgr_Selection)& theSel,
                                       const Standard_Integer theMode)
{
  switch (theMode)
  {
  case 0:   // creation of face sensitives for selection of the whole box
  {
    Handle(SelectMgr_EntityOwner) anOwnr = new SelectMgr_EntityOwner (this, 5);
    for (Standard_Integer  aFaceIdx = 1; aFaceIdx <= myNbFaces; aFaceIdx++)
    {
      Select3D_TypeOfSensitivity aIsInteriorSensitivity = myIsInterior;
      theSel->Add (new  Select3D_SensitiveFace (anOwnr,
                                                myFaces[aFaceIdx]->PointArray(),
                                                aIsInteriorSensitivity));
    }
    break;
  }
  case 1: // creation of edge sensitives for selection of box edges only
  {
    for (Standard_Integer anEdgeIdx = 1; anEdgeIdx <= 12; anEdgeIdx++)
    {
      // 1 owner per edge, where 6 is a priority of the sensitive
      Handle(MySelection_EdgeOwner) anOwnr = new MySelection_EdgeOwner (this, anEdgeIdx, 6);
      theSel->Add (new  Select3D_SensitiveSegment (anOwnr,
                                                   FirstPnt[anEdgeIdx]),
                                                   LastPnt[anEdgeIdx]));
    }
    break;
  }
  }
}

~~~~

The algorithms for creating selection structures store sensitive primitives in <i>SelectMgr_Selection</i> instance. Each <i>SelectMgr_Selection</i> sequence in the list of selections of the object must correspond to a particular selection mode.

To describe the decomposition of the object into selectable primitives, a set of ready-made sensitive entities is supplied in <i>Select3D</i> package. Custom sensitive primitives can be defined through inheritance from <i>SelectBasics_SensitiveEntity</i>.

To make custom interactive objects selectable or customize selection modes of existing objects, the entity owners must be defined. They must inherit <i>SelectMgr_EntityOwner</i> interface.


Selection structures for any interactive object are created in <i>SelectMgr_SelectableObject::ComputeSelection()</i> method.

The example below shows how computation of different selection modes of the topological shape can be done using standard OCCT mechanisms, implemented in <i>StdSelect_BRepSelectionTool</i>.

~~~~
  void MyInteractiveObject::ComputeSelection (const Handle(SelectMgr_Selection)& theSelection,
                                              const Standard_Integer theMode)
  {
    switch (theMode)
    {
      case 0:
        StdSelect_BRepSelectionTool::Load (theSelection, this, myTopoDSShape, TopAbs_SHAPE);
        break;
      case 1:
        StdSelect_BRepSelectionTool::Load (theSelection, this, myTopoDSShape, TopAbs_VERTEX);
        break;
      case 2:
        StdSelect_BRepSelectionTool::Load (theSelection, this, myTopoDSShape, TopAbs_EDGE);
        break;
      case 3:
        StdSelect_BRepSelectionTool::Load (theSelection, this, myTopoDSShape, TopAbs_WIRE);
        break;
      case 4:
        StdSelect_BRepSelectionTool::Load (theSelection, this, myTopoDSShape, TopAbs_FACE);
        break;
    }
  }
~~~~

The <i>StdSelect_BRepSelectionTool</i> class provides a high level API for computing sensitive entities of the given type (for example, face, vertex, edge, wire and others) using topological data from the given <i>TopoDS_Shape</i>.

The traditional way of highlighting selected entity owners adopted by Open CASCADE Technology assumes that each entity owner highlights itself on its own. This approach has two drawbacks:

  - each entity owner has to maintain its own <i>Prs3d_Presentation</i> object, that results in a large memory overhead for thousands of owners;
  - drawing selected owners one by one is not efficient from the OpenGL usage viewpoint.

Therefore, to overcome these limitations, OCCT has an alternative way to implement the highlighting of a selected presentation. Using this approach, the interactive object itself will be responsible for the highlighting, not the entity owner.

On the basis of <i>SelectMgr_EntityOwner::IsAutoHilight()</i> return value, <i>AIS_LocalContext</i> object either uses the traditional way of highlighting (in case if <i>IsAutoHilight()</i> returns true) or groups such owners according to their selectable objects and finally calls <i> SelectMgr_SelectableObject::HilightSelected()</i> or <i>SelectMgr_SelectableObject::ClearSelected()</i>, passing a group of owners as an argument.

Hence, an application can derive its own interactive object and redefine virtual methods <i>HilightSelected()</i>, <i>ClearSelected()</i> and <i>HilightOwnerWithColor()</i> from <i>SelectMgr_SelectableObject</i>. <i>SelectMgr_SelectableObject::GetHilightPresentation</i> and <i>SelectMgr_SelectableObject::GetSelectPresentation</i> methods can be used to optimize filling of selection and highlight presentations according to the user's needs.

The <i>AIS_InteractiveContext::HighlightSelected()</i> method can be used for efficient redrawing of the selection presentation for a given interactive object from an application code.

After all the necessary sensitive entities are computed and packed in <i>SelectMgr_Selection</i> instance with the corresponding owners in a redefinition of <i>SelectMgr_SelectableObject::ComputeSelection()</i> method, it is necessary to register the prepared selection in <i>SelectMgr_SelectionManager</i> through the following steps:
  - if there was no <i>AIS_InteractiveContext</i> opened, create an interactive context and display the selectable object in it;
  - load the selectable object to the selection manager of the interactive context using <i>AIS_InteractiveContext::Load()</i> method. If the selection mode passed as a parameter to this method is not equal to -1, <i>ComputeSelection()</i> for this selection mode will be called;
  - activate or deactivate the defined selection mode using <i>AIS_InteractiveContext::Activate()</i> or <i>AIS_InteractiveContext::Deactivate()</i> methods.

After these steps, the selection manager of the created interactive context will contain the given object  and its selection entities, and they will be involved in the detection procedure.

The code snippet below illustrates the above steps. It also contains the code to start the detection procedure and parse the results of selection.

~~~~~

// Suppose there is an instance of class InteractiveBox from the previous sample.
// It contains an implementation of method InteractiveBox::ComputeSelection() for selection
// modes 0 (whole box must be selected) and 1 (edge of the box must be selectable)
Handle(InteractiveBox) aBox;

// Assume there is a created interactive context
const Handle(AIS_InteractiveContext)& aContext = GetContext();
// To prevent automatic activation of the default selection mode
aContext->SetAutoActivateSelection (Standard_False);

aContext->Display (aBox);

// Load a box to the selection manager without computation of any selection mode
aContext->Load (aBox, -1, Standard_True);
// Activate edge selection
aContext->Activate (aBox, 1);

// Run the detection mechanism for activated entities in the current mouse coordinates and
// in the current view. Detected owners will be highlighted with context highlight color
aContext->MoveTo (aXMousePos, aYMousePos, myView);
// Select the detected owners
aContext->Select();
// Iterate through the selected owners
for (aContext->InitSelected(); aContext->MoreSelected() && !aHasSelected; aContext->NextSelected())
{
  Handle(AIS_InteractiveObject) anIO = aContext->SelectedInteractive();
}

// deactivate all selection modes for aBox1
aContext->Deactivate (aBox1);

~~~~~

It is also important to know, that there are 2 types of detection implemented for rectangular selection in OCCT:
  - <b>inclusive</b> detection. In this case the sensitive primitive is considered detected only when all its points are included in the area defined by the selection rectangle;
  - <b>overlap</b> detection. In this case the sensitive primitive is considered detected when it is partially overlapped by the selection rectangle.

The standard OCCT selection mechanism uses inclusion detection by default. To change this, use the following code:

~~~~~

// Assume there is a created interactive context 
const Handle(AIS_InteractiveContext)& aContext = GetContext();
// Retrieve the current viewer selector
const Handle(StdSelect_ViewerSelector3d)& aMainSelector = aContext->MainSelector();
// Set the flag to allow overlap detection
aMainSelector->AllowOverlapDetection (Standard_True);

~~~~~

